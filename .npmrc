# 严格检查 engines 字段
# 如果 Node.js 或 pnpm 版本不符合 package.json 中的 engines 要求,会报错
engine-strict=true

# 强制使用 pnpm (禁止使用 npm 或 yarn)
package-manager-strict=true

# 自动安装 peer dependencies
# 默认行为 (auto-install-peers=false) (pnpm：“这是 peer，你自己装。”)
# auto-install-peers=true (pnpm：“行，我帮你装一个合适版本的 eslint。”)
auto-install-peers=true

# hoist=true（默认）时发生了什么？pnpm 默认会 “好心” 地将 xxx/ 路径下的 node_modules 中依赖提升到 repo_root/ 项目根路径下的 node_modules 中，这样 packages/a/ 路径下的文件就能使用 packages/b/ 路径下的 node_modules 中的依赖
# hoist=false 时设定不提升依赖到根目录的 node_modules 
# 这样可以避免"幽灵依赖"问题 (使用了没有声明的依赖)
hoist=false

# pnpm 默认是：node_modules/pkg → symlink → .pnpm/pkg@x.y.z/node_modules/pkg
# symlink=false 使用 hard link（硬链接）而不是 symlink (Windows 兼容性更好, Windows symlink 需要管理员权限)
# symlink=false

# 全局 bin 目录 (可选,取消注释以自定义)
# global-bin-dir=~/.pnpm-global/bin

# 使用锁文件，必须严格按 pnpm-lock.yaml 安装，确保团队成员安装的依赖版本完全一致
lockfile=true

# 不忽略 workspace 的依赖提升 (不要使用该配置项)
# shamefully-hoist=false

# peerDependencies 默认用户项目中已经包含了相应依赖，无需再在安装本人依赖时重新安装一遍
# strict-peer-dependencies=true 严格遵守 peerDependencies 中依赖版本，否则报错
# strict-peer-dependencies=false 版本不对时不会报错，风险由用户承担
strict-peer-dependencies=true
